
h1. Ενημέρωση για καθυστέρηση

Η περίπτωση χρήσης “ενημέρωση για καθυστέρηση” περιγράφει ότι θα πρέπει να ενημερώνονται όλοι οι δανειζόμενοι οι οποίοι έχουν καθυστερήσει την επιστροφή κάποιου αντιτύπου. Η περίπτωση χρήσης “ενημέρωση για καθυστέρηση” περιγράφηκε στο παράδειγμα 3.8 του βιβλίου. Δεν ασχοληθήκαμε όμως με τη συγκεκριμένη περίπτωση χρήσης στη φάση της σχεδίασης. Η σχεδίαση της λύσης γι' αυτή την περίπτωση χρήσης έχει κάποιο ενδιαφέρον. Και περισσότερο ενδιαφέρον έχει ο τρόπος σκέψης για να φθάσουμε σε κάποια λύση. Αν σκεφτούμε τις διαφορετικές επιλογές μας για τη συγκεκριμένη περίπτωση χρήσης θα δούμε ότι υπάρχουν αρκετές επιλογές σχεδίασης ακόμα και για μία σχετικά απλή απαίτηση του λογισμικού. 

Δύο είναι τα βασικά χαρακτηριστικά της περίπτωσης χρήσης:

# Δεν εντάσσεται στο υπόλοιπο λογισμικό μέσω της διεπαφής χρήστη αλλά ενεργοποιείται από το χρόνο. 
# Αποστέλλει μηνύματα ηλεκτρονικού ταχυδρομείου και επικοινωνεί με ένα εξωτερικό υποσύστημα που είναι ο διακομιστής ηλεκτρονικού ταχυδρομείου. Ευτυχώς για τη Java έχουμε το "JavaMail API":http://java.sun.com/products/javamail/ με το οποίο μπορούμε να συνθέσουμε και να αποστείλουμε μηνύματα ηλεκτρονικού ταχυδρομείου.

Το πρώτο το χαρακτηριστικό θα το αγνοήσουμε. Θα σχεδιάσουμε το λογισμικό αγνοώντας το γεγονός ενεργοποιείται από το χρόνο. Θα ασχοληθούμε με το δεύτερο χαρακτηριστικό που είναι η επικοινωνία με κάποιο εξωτερικό υποσύστημα και τα θέματα που θα μας απασχολήσουν είναι η ελεγξιμότητα και η επεκτασιμότητα. Το JavaMail API μας παρέχει μία σημαντική διευκόλυνση αλλά το πρόβλημα της σχεδίασης δεν εξαντλείται βέβαια στη χρήση του API.

Η βασική κλάση που θα υλοποιήσει την ενημέρωση για καθυστέρηση είναι η κλάση @NotificationService@. Όπως μας λέει και το όνομά της είναι μία κλάση που θα τοποθετηθεί στο πακέτο @service@. Ας ξεκινήσουμε τη σχεδίαση από τα βασικά ζητούμενα της περίπτωσης χρήσης. Το πρώτο ζητούμενο είναι η αναζήτηση από τη βάση δεδομένων των δανεισμών για τους οποίους έχει καθυστερήσει η επιστροφή των αντιτύπων. Το δεύτερο ζητούμενο είναι η σύνθεση και η αποστολή των μηνυμάτων ηλεκτρονικού ταχυδρομείου. Θα εξετάσουμε τα δύο ζητούμενα ξεχωριστά.

!diagrams/NotificationServiceAndDao.png!

Η πρώτη επιλογή είναι να ζητήσουμε όλα τα αντικείμενα των δανεισμών και να ρωτήσουμε το αντικείμενο της κλάσης @Loan@ αν δεν έχει γίνει η επιστροφή του αντιτύπου και αν έχει παρέλθει η ημερομηνία επιστροφής. Ένα υπόδειγμα κώδικα είναι το παρακάτω:

bc.  
    List<Loan> allLoans = loanDao.findAll();
    for(Loan loan : allLoans) {         
        if (loan.isPending() && loan.isOverdue()) {
            // .....
        }
    }

Το πρόβλημα με αυτή την επιλογή σχεδίασης είναι η απόδοση. Θα πρέπει να βρούμε όλους τους δανεισμούς που έχουν πραγματοποιηθεί μόνο για να βρούμε ένα μικρό υποσύνολο δανεισμών. Στο άλλο άκρο το αντικείμενο DAO επιστρέφει μόνο το υποσύνολο που μας ενδιαφέρει δηλαδή μόνο τους δανεισμούς για τους οποίους έχει παρέλθει η προθεσμία επιστροφής. Το υπόδειγμα του κώδικα είναι το παρακάτω:

bc.   
    List<Loan> allLoans = loanDao.findOverdue();
    for(Loan loan : allLoans) {         
        // .....
    }
    
Μπορούμε να δούμε ότι η μέθοδος @findOverdue@ αποφασίζει για το ποια αντικείμενα δανεισμών είναι αυτά για τα οποία έχει παρέλθει η ημερομηνία επιστροφής. Το πρόβλημα με αυτή την επιλογή σχεδίασης είναι ότι η απόφαση μετατίθεται στην ίδια τη βάση δεδομένων. Αντίθετα την απόφαση αυτή (δηλαδή για το αν έχει παρέλθει η προθεσμία επιστροφής) τη σχεδιάσαμε να ανήκει στη λογική του πεδίου των κλάσεων δηλαδή του λογισμικού (βλέπε παράδειγμα 8-6 του βιβλίου) και όχι στη βάση δεδομένων. Η επιλογή αυτή έχει προφανώς πάρα πολλά πλεονεκτήματα όσον αφορά στις δυνατότητες που έχουμε να αλλάξουμε τη λογική υπολογισμού των προθεσμιών επιστροφής των αντιτύπων.

Η τελική σχεδίαση που θα προκρίνουμε είναι κάπου στη μέση. Η βάση δεδομένων θα μας δώσει όλους τους δανεισμούς που εκκρεμούν. Η απόφαση για το αν έχει παρέλθει η προθεσμία επιστροφής θα ανήκει στη λογική του πεδίου δηλαδή στην κλάση @Loan@. Το υπόδειγμα του κώδικα είναι:

bc.        
    List<Loan> allLoans = loanDao.findAllPending();     
    for(Loan loan : allLoans) {
        if (loan.isOverdue()) {             
            // ....
        }
    }

Η απόφαση για το αν ένας δανεισμός εκκρεμεί είναι σχετικά εύκολη για να το αναθέσουμε στη βάση δεδομένων. Ένας δανεισμός εκκρεμεί όταν η ημερομηνία επιστροφής δεν έχει οριστεί. Βασιζόμενο σε αυτό το κριτήριο το οποίο δεν φαίνεται να αλλάξει (είναι σταθερό) η βάση δεδομένων θα μας δώσει γρήγορα τις εγγραφές αυτές που ζητάμε. Η απόφαση που λαμβάνουμε δεν είναι αναγκαστικά και η τελική. Θα πρέπει να εκτελέσουμε και τους κατάλληλους ελέγχους χρονισμού (βλ. ενότητα 11.1.3 του βιβλίου) σε ρεαλιστικό περιβάλλον προκειμένου να επιβεβαιώσουμε τις αποφάσεις μας. Για εκτενέστερη εξέταση της σχέσης μεταξύ λογικής του πεδίου και βάσης δεδομένων βλέπε "εδώ":http://martinfowler.com/articles/dblogic.html.¨

h2. Αποστολή μηνυμάτων ηλεκτρονικού ταχυδρομείου

Θυμίζουμε ότι ο στόχος μας είναι να αποστείλουμε μηνύματα ηλεκτρονικού ταχυδρομείου σε όσους δεν έχουν επιστρέψει τα αντίτυπα που έχουν δανειστεί και βέβαια έχει παρέλθει η προθεσμία επιστροφής. Στην προηγούμενη ενότητα ασχοληθήκαμε με το πρώτο σκέλος του προβλήματος που ήταν ο εντοπισμός των δανεισμών αυτών. Το δεύτερο σκέλος του προβλήματος είναι επίσης σημαντικό.

Έχουμε το ερώτημα της ανάθεσης σε κάποια κλάση της αποστολής μηνυμάτων ηλεκτρονικού ταχυδρομείου στον δανειζόμενο όταν αυτός αργήσει την επιστροφή ενός αντιτύπου. Θα αναθέσουμε την αρμοδιότητα αυτή στην κλάση @NotificationService@. Για την υλοποίηση της αποστολής των μηνυμάτων μπορούμε να χρησιμοποιήσουμε το JavaMail API.  Έχουμε όμως ένα βασικό πρόβλημα και αυτό είναι η υψηλή σύζευξη της κλάσης @NotificationService@ με ένα εξωτερικό υποσύστημα που είναι το υποσύστημα του ηλεκτρονικού ταχυδρομείου. Η σύζευξη κάνει τον έλεγχο της κλάσης @NotificationService@ εξαιρετικά δύσκολο. Θέλουμε να κωδικοποιήσουμε και να εκτελέσουμε αυτόματους ελέγχους με το JUnit στην υπηρεσία αποστολής μηνυμάτων. Προφανώς δεν μπορούμε στα πλαίσια των αυτόματων ελέγχων να στέλνουμε πραγματικά e-mails σε πραγματικές διευθύνσεις ηλεκτρονικού ταχυδρομείου. Οι έλεγχοι μας δεν θα έχουν τα χαρακτηριστικά των καλών ελέγχων όπως τα έχουμε περιγράψει στην ενότητα 10.3.1 του βιβλίου. Επομένως το ζητούμενο είναι πρώτον να μειώσουμε τη σύζευξη με το εξωτερικό υποσύστημα (το υποσύστημα αποστολής e-mails) και δεύτερον να μπορέσουμε να εκτελέσουμε αυτόματους ελέγχους στην υπηρεσία @NotificationService@. Όπως γίνεται συνήθως σε αυτές τις  περιπτώσεις καταφεύγουμε στη μεταβίβαση (ενότητα 8.5.2 του βιβλίου) και στην αφαίρεση. Ορίζουμε τη διεπαφή @EmailProvider@ η οποία αναλαμβάνει να προωθεί μηνύματα προς στον διακομιστή ηλεκτρονικού ταχυδρομείου. Αντικείμενα που υλοποιούν τη διεπαφή αυτή, θα γνωρίζουν τις λεπτομέρειες που αφορούν το σύστημα ηλεκτρονικού ταχυδρομείου. Τα αντικείμενα αυτά πιθανόν να χρησιμοποιούν και το JavaMail API. 

Η διεπαφή @EmailProvider@ θα έχει μόνο μία μέθοδο τη μέθοδο @sendEmail@ με πιθανή υπογραφή
@sendEmail(EmailAddress from, EmailAddress to, String subject, String body)@
όπου @from@ η διεύθυνση του αποστολέα, @to@ η διεύθυνση του παραλήπτη, @subject@ το θέμα του μηνύματος και τέλος @body@ το σώμα του μηνύματος. Αξίζει σε αυτό το σημείο να θυμίσουμε ότι ήδη έχουμε ορίσει την κλάση @EmailAddress@ για τις διευθύνσεις ηλεκτρονικού ταχυδρομείου. Θα μπορούσαμε βέβαια να ορίσουμε και μία νέα κλάση, την κλάση @EmailMessage@ που ομαδοποιεί τα παραπάνω δεδομένα.

!diagrams/EmailAddress.png!

Έχουμε βέβαια την επίγνωση ότι η κλάση @EmailMessage@ δεν έχει συμπεριφορά αλλά μόνο δεδομένα γεγονός που είναι βέβαια αρνητικό. Επιλέγουμε όμως να ορίσουμε μία νέα κλάση γιατί μας παρέχει περισσότερες δυνατότητες επεκτασιμότητας. Αν για παράδειγμα οι παραλήπτες είναι περισσότεροι από έναν τότε έχοντας την κλάση @EmailMessage@ μπορούμε εύκολα να επεκτείνουμε το λογισμικό με νέα λειτουργικότητα. 

!diagrams/BorrowerSendMail.png!

Το παραπάνω σχήμα παρουσιάζει την τελική λύση. Η κλάση @NotificationService@ χρησιμοποιεί κάποιο αντικείμενο της διεπαφής @EmailProvider@ προκειμένου να γίνει η αποστολή των μηνυμάτων ηλεκτρονικού ταχυδρομείου. Η κλάση @EmailProviderImpl@ υλοποιεί τη διεπαφή για την πραγματική αποστολή των μηνυμάτων. Η κλάση θα ενθυλακώνει όλη τη γνώση που αφορά το εξωτερικό υποσύστημα του διακομιστή ηλεκτρονικού ταχυδρομείου του πανεπιστήμιου. Θα ενθυλακώνει επίσης και τη χρήση του JavaMail API. Η κλάση @EmailProviderStub@ είναι το στέλεχος (βλέπε ενότητα 10.3.2 του βιβλίου) το οποίο χρησιμοποιηθεί για έλεγχο. Αξίζει να σημειώσουμε ότι η δομή του σχήματος μας θυμίζει τη δομή του σχήματος 10-13 του βιβλίου, όπου και πάλι χρησιμοποιήσαμε ένα στέλεχος για την υποκατάσταση κάποιας υλοποίησης, όταν εκτελούμε τους ελέγχους. 

h2. Βάζοντάς τα όλα μαζί

Έχοντας λάβει τις αποφάσεις σχεδίασης μπορούμε να προχωρήσουμε και σε κάποια υλοποίηση. Το πρώτο που πρέπει να έχουμε είναι ο κώδικας της κλάσης @NotificationService@. Έστω ο παρακάτω κώδικας:


bc.  
public class NotificationService {
    private EmailProvider provider;

bc. 
    public void setProvider(EmailProvider provider) {
        this.provider = provider;
    }

bc. 
    public void notifyBorrowers() {
        if (provider == null) {
            throw new LibraryException();
        }

bc. 
        LoanDAO loanDao = DAOFactory.getFactory().getLoanDAO();
        List<Loan> allLoans = loanDao.findAllPending();
        for (Loan loan : allLoans) {
            if (loan.isOverdue() && loan.getBorrower().getEmail()!=null &&
            		loan.getBorrower().getEmail().isValid()) {
                String message = composeMessage(loan.getItem().getBook(),
                        -loan.daysToDue());
                sendEmail(loan.getBorrower(),
                        "Καθυστέρηση Αντιτύπου", message);
            }
        }
    }
 
bc. 
    private void sendEmail(Borrower borrower,
            String subject, String message) {
        EmailAddress eMail  = borrower.getEmail();
        if (eMail == null || !eMail.isValid()) {
            return;
        }
        
bc. 
        EmailMessage emailMessage = new EmailMessage();
        emailMessage.setTo(eMail);
        emailMessage.setSubject(subject);
        emailMessage.setBody(message);
        provider.sendEmail(emailMessage);
    }

bc.  
    private String composeMessage(Book book, long overdue) {
        String message = "Έχετε καθυστερήσει το βιβλίο με Τίτλο ";
        message += book.getTitle();
        message += " για ";
        message += overdue;
        message += " ημέρες ";
        return message;
    }
}



Καταρχήν έχουμε το πεδίο @provider@ όπου φυλάσσεται το αντικείμενο που αναλαμβάνει να στείλει το μήνυμα στον δανειζόμενο. Φυσικά το πεδίο είναι τύπου @EmailProvider@ που είναι η διεπαφή που ορίσαμε παραπάνω. Θα πρέπει βέβαια να υπάρχουν και μέθοδοι που ενημερώνουν το πεδίο. Η υλοποίηση της ενημέρωσης δίνεται από τη μέθοδο @notifyBorrowers@. Αναζητούνται όλοι οι δανεισμοί που εκκρεμούν και εντοπίζονται αυτοί για τους οποίους έχει παρέλθει η ημερομηνία επιστροφής. Γίνεται η σύνθεση του μηνύματος με τη μέθοδο @composeMessage@ και κατόπιν η αποστολή του μηνύματος μέσω της μεθόδου @sendEmail@ με τη χρήση του αντικειμένου @provider@. 

Το ερώτημα του αυτόματου ελέγχου της μεθόδου @notifyBorrowers@ παραμένει ακόμα ανοιχτό. Όπως έχουμε αναφέρει θέλουμε να ελέγξουμε τη μέθοδο @notifyBorrowers@ της κλάσης @NotificationService@ και για το λόγο αυτό θα χρησιμοποιήσουμε την κλάση @EmailProviderStub@. Όταν εκτελεστεί η μέθοδος @notifyBorrowers@ θα πρέπει στείλει μήνυμα στους δανειζομένους οι οποίοι έχουν αργήσει την επιστροφή αντιτύπου και φυσικά μόνο για αυτούς. Ο έλεγχος της μεθόδου @notifyBorrowers@ περιλαμβάνει την προετοιμασία των δεδομένων με δανεισμούς που έχουν λήξει και δανεισμούς που δεν έχουν λήξει. Το μόνο που χρειάζεται όταν εκτελέσουμε τον έλεγχο είναι να συγκρατήσουμε την πληροφορία για τους δανεισμούς που έχουν λήξει. Την πληροφορία αυτή θα τη συγκρίνουμε με τις αναμενόμενες τιμές. Επομένως το μόνο που χρειάζεται για την υλοποίηση της κλάσης @EmailProviderStub@ είναι να προσθέτουμε  σε έναν κατάλογο όλα τα μηνύματα που αποστέλλονται με την κλήση της μεθόδου sendEmail. Με την ολοκλήρωση του ελέγχου συγκρίνουμε τα περιεχόμενα του καταλόγου με τις αναμενόμενες τιμές. Ας δούμε την υλοποίηση:

bc. public class EmailProviderStub implements EmailProvider{
    List<EmailMessage> allMessages = new ArrayList<EmailMessage>(); 
    public List<EmailMessage> getAllEmails() {
        return allMessages;
    }
    public void sendEmail(EmailMessage message) {        
        allMessages.add(message);
    }
}

Έχουμε τη συλλογή @allMessages@ που είναι και ο κατάλογος των μηνυμάτων ηλεκτρονικού ταχυδρομείου. Κάθε φορά που καλείται η μέθοδος @sendEmail@ προστίθεται η διεύθυνση του ηλεκτρονικού ταχυδρομείου στον κατάλογο @allMessages@. Ο κατάλογος όλων των μηνυμάτων επιστρέφεται με τη μέθοδο @getAllEmails@ σε περίπτωση που ζητηθεί από τον κώδικα ελέγχου.

